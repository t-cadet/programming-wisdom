<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SPA Blog</title>
    <style>
        /* #region --- 1. CSS Variables & Theme --- */
        :root {
            --scale: 1.0;
            --font-size-base: calc(16px * var(--scale));

            /* Default Theme: Warm Sand */
            --bg: #f4ead6;
            --accent: #b88b5b;
            --text: #3d352a;
            --heading-text: #2c251d;
            --muted: #857f75;
            --card-bg: #fffbf2;
            --border-color: #e0d8c7;
            --code-bg: #282c34; /* Dark background for code */
            --code-text: #abb2bf;
            --link-color: #9e6f42;
            --focus-ring: 0 0 0 2px var(--bg), 0 0 0 4px var(--accent);

            /* Syntax Highlighting Colors */
            --tk-keyword: #e6c84a;
            --tk-string: #62b36e;
            --tk-comment: #8b8b8b;
            --tk-preproc: #6f6f6f;
            --tk-number: #8a6adf;
        }
        /* #endregion */

        /* #region --- 2. Base & Layout --- */
        *, *::before, *::after { box-sizing: border-box; }

        html { font-size: var(--font-size-base); }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg);
            color: var(--text);
            margin: 0;
            line-height: 1.6;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        #app {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        header, footer {
            flex-shrink: 0;
            padding: 1rem 2rem;
            color: var(--heading-text);
        }

        header {
            position: sticky;
            top: 0;
            background-color: color-mix(in srgb, var(--bg) 80%, transparent);
            backdrop-filter: blur(5px);
            z-index: 100;
            border-bottom: 1px solid var(--border-color);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
        }
        .blog-title { font-size: 1.5rem; font-weight: bold; cursor: pointer; }
        .settings-icon { cursor: pointer; font-size: 1.5rem; }

        .accolade-svg { fill: var(--accent); width: 100%; height: 30px; }

        main {
            flex-grow: 1;
            width: 100%;
            max-width: 1600px;
            margin: 0 auto;
            padding: 1rem 2rem;
        }

        footer { text-align: center; font-size: 0.9rem; color: var(--muted); }
        /* #endregion */

        /* #region --- 3. Index View & Table --- */
        #index-view { padding-top: 1rem; }
        .filter-controls {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
            align-items: center;
        }
        #filter-input {
            flex-grow: 1;
            padding: 0.5rem;
            border: 1px solid var(--border-color);
            background-color: var(--card-bg);
            color: var(--text);
            border-radius: 4px;
        }
        #filter-input:focus { outline: none; box-shadow: var(--focus-ring); }
        #match-count { font-style: italic; color: var(--muted); }

        .table-container {
            overflow-y: auto;
            max-height: calc(100vh - 250px); /* Adjust based on header/footer/filter height */
            border: 1px solid var(--border-color);
            border-radius: 4px;
        }

        .articles-table {
            width: 100%;
            border-collapse: collapse;
        }
        .articles-table th {
            position: sticky;
            top: 0;
            background: var(--card-bg);
            padding: 0.75rem;
            text-align: left;
            cursor: pointer;
            user-select: none;
        }
        .articles-table th[aria-sort] .sort-indicator { content: ' ' / ' '; }
        .articles-table th[aria-sort="ascending"]::after { content: ' ▲'; }
        .articles-table th[aria-sort="descending"]::after { content: ' ▼'; }

        .articles-table tbody tr {
            cursor: pointer;
            border-bottom: 1px solid var(--border-color);
        }
        .articles-table tbody tr:last-child { border-bottom: none; }
        .articles-table tbody tr:hover { background-color: color-mix(in srgb, var(--accent) 10%, var(--card-bg)); }
        .articles-table tbody tr:focus { outline: none; box-shadow: var(--focus-ring); }

        .articles-table td { padding: 0.75rem; }
        .articles-table td .highlight { background-color: color-mix(in srgb, var(--accent) 40%, transparent); }
        /* #endregion */

        /* #region --- 4. Article View & Sidebar --- */
        #article-view {
            display: none; /* Hidden by default */
            grid-template-columns: 420px 1fr;
            gap: 2.5rem;
        }

        #article-sidebar {
            position: sticky;
            top: 125px; /* Below header */
            align-self: start;
            max-height: calc(100vh - 100px);
            display: flex;
            flex-direction: column;
        }

        #sidebar-menu .articles-table {
            font-size: 0.9rem;
            table-layout: fixed; /* Important for predictable column widths */
            width: 100%;
        }
        #sidebar-menu .articles-table th {
            text-align: left;
            padding: 0.4rem 0.6rem;
            font-weight: bold;
        }
        #sidebar-menu .articles-table .date-cell {
            width: 95px; /* Give date a fixed width */
            white-space: nowrap;
            color: var(--muted);
            text-overflow: hidden;
        }
        #sidebar-menu .articles-table td {
            padding: 0.4rem 0.6rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #article-container .post { max-width: 800px; }

        /* Responsive: Collapse sidebar */
        @media (max-width: 900px) {
            #article-view { grid-template-columns: 1fr; }
            #article-sidebar { /* Becomes a drawer - simplified for this spec */
                display: none; /* A real implementation would use a toggle button */
            }
        }
        /* #endregion */

        /* #region --- 5. Article & Authoring Classes --- */
        .post-title { font-size: 2.5rem; color: var(--heading-text); margin-bottom: 0; }
        .post-subtitle { font-size: 1.5rem; color: var(--muted); margin-top: 0.5rem; font-weight: normal; }
        .post-meta { display: flex; flex-wrap: wrap; gap: 0.5rem 1.5rem; margin: 1.5rem 0; color: var(--muted); font-size: 0.9rem; }
        .post-topics .tag { background-color: color-mix(in srgb, var(--accent) 20%, transparent); padding: 0.1rem 0.5rem; border-radius: 4px; }
        .lead { font-size: 1.2rem; color: color-mix(in srgb, var(--text) 85%, transparent); }

        a { color: var(--link-color); text-decoration: none; }
        a:hover { text-decoration: underline; }

        h1, h2, h3 { color: var(--heading-text); }
        hr { border: 0; border-top: 1px solid var(--border-color); }
        /* #endregion */

        /* #region --- 6. Code Blocks & Highlighting --- */
        pre {
            background-color: var(--code-bg);
            color: var(--code-text);
            padding: 1rem;
            border-radius: 4px;
            overflow-x: auto;
            font-family: 'SF Mono', 'Consolas', 'Menlo', monospace;
            font-size: 0.9rem;
        }
        code { font-family: inherit; }
        pre code { padding: 0; background: none; }

        .tk-keyword { color: var(--tk-keyword); }
        .tk-string  { color: var(--tk-string); }
        .tk-comment { color: var(--tk-comment); font-style: italic; }
        .tk-preproc { color: var(--tk-preproc); }
        .tk-number  { color: var(--tk-number); }
        /* #endregion */

        /* #region --- 7. Settings Panel --- */
        #settings-panel {
            display: none; /* Hidden by default */
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--card-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 2rem;
            z-index: 200;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        }
        .settings-overlay {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: transparent;
            z-index: 199;
        }
        .settings-grid { display: grid; grid-template-columns: auto 1fr auto; gap: 1rem; align-items: center; }
        .settings-grid label { font-weight: bold; }
        .color-picker-wrapper { width: 30px; height: 30px; border: 1px solid var(--border-color); border-radius: 50%; overflow: hidden; }
        .color-picker-wrapper input[type="color"] { width: 40px; height: 40px; border: none; padding: 0; margin: -5px; cursor: pointer; }
        #contrast-warning { color: #d93025; font-weight: bold; }
        #reset-theme-btn {
            background-color: var(--accent);
            color: var(--card-bg);
            border: 1px solid transparent;
            border-radius: 4px;
            padding: 0.6rem 1.2rem;
            font-size: 0.9rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease;
            -webkit-appearance: none;
            appearance: none;
        }

        #reset-theme-btn:hover {
            filter: brightness(110%);
        }

        #reset-theme-btn:focus-visible {
            outline: none;
            box-shadow: var(--focus-ring);
        }

        #reset-theme-btn:active {
            transform: scale(0.97);
            filter: brightness(95%);
        }
        /* #endregion */

        /* #region --- 8. Utility & Misc --- */
        .hidden { display: none; }
        .spinner {
            border: 4px solid color-mix(in srgb, var(--accent) 20%, transparent);
            border-top: 4px solid var(--accent);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 4rem auto;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        /* #endregion */
    </style>
</head>
<body>

    <div id="app">
        <!-- Header -->
        <header id="main-header">
            <div class="header-content">
                <div class="blog-title" id="blog-title">My Blog</div>
                <div class="settings-icon" id="settings-icon" title="Settings">⚙️</div>
            </div>
            <svg class="accolade-svg" viewBox="0 0 100 10" preserveAspectRatio="none"><path d="M0 5 C 20 0, 30 10, 50 5 S 80 0, 100 5 L 100 10 L 0 10 Z"></path></svg>
        </header>

        <!-- Main Content -->
        <main>
            <!-- Index View -->
            <div id="index-view">
                <div class="filter-controls">
                    <input type="search" id="filter-input" placeholder="Regex filter: 2025.*;Muratori">
                    <span id="match-count"></span>
                </div>
                <div class="table-container" id="table-container">
                    <table class="articles-table">
                        <thead>
                            <tr>
                                <th data-sort="date">Date</th>
                                <th data-sort="last_update">Updated</th>
                                <th data-sort="title">Title</th>
                                <th data-sort="authors">Authors</th>
                                <th data-sort="topics">Topics</th>
                            </tr>
                        </thead>
                        <tbody id="articles-tbody">
                            <!-- JS will populate this -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Article View -->
            <div id="article-view">
                <aside id="article-sidebar">
                    <div class="table-container" id="sidebar-menu">
                        <!-- JS will populate this with a narrow table -->
                    </div>
                </aside>
                <div id="article-content">
                    <div id="article-spinner" class="spinner"></div>
                    <div id="article-container">
                        <!-- Fetched article HTML will be injected here -->
                    </div>
                </div>
            </div>
        </main>

        <!-- Footer -->
        <footer>
            <svg class="accolade-svg" viewBox="0 0 100 10" preserveAspectRatio="none" style="transform: scaleY(-1);"><path d="M0 5 C 20 0, 30 10, 50 5 S 80 0, 100 5 L 100 10 L 0 10 Z"></path></svg>
            <p>&copy; 2025 Your Name Here. All rights reserved.</p>
        </footer>
    </div>

    <!-- Settings Panel -->
    <div class="settings-overlay" id="settings-overlay"></div>
    <div id="settings-panel">
        <h3>Theme Settings</h3>
        <div class="settings-grid">
            <label for="font-size-slider">Font Size</label>
            <input type="range" id="font-size-slider" min="0.8" max="1.5" step="0.05">
            <span id="font-size-value">1.0x</span>

            <label for="accent-color-picker">Accent</label>
            <div class="color-picker-wrapper">
                <input type="color" id="accent-color-picker">
            </div>
            <span></span>

            <label for="bg-color-picker">Background</label>
            <div class="color-picker-wrapper">
                <input type="color" id="bg-color-picker">
            </div>
            <span id="contrast-warning"></span>
        </div>
        <br>
        <button id="reset-theme-btn">Reset to Defaults</button>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // #region --- 1. State & Constants ---
        const C_KEYWORDS = new Set(['auto', 'break', 'case', 'char', 'const', 'continue', 'default', 'do', 'double', 'else', 'enum', 'extern', 'float', 'for', 'goto', 'if', 'int', 'long', 'register', 'return', 'short', 'signed', 'sizeof', 'static', 'struct', 'switch', 'typedef', 'union', 'unsigned', 'void', 'volatile', 'while']);

        const state = {
            articles: [], // { slug, date, updated, title, authors, topics, element }[]
            sort: { column: 'last_update', order: 'asc' },
            filterRegex: null,
            focusedRowIndex: -1,
        };

        const defaultTheme = {
            scale: 1.0,
            accent: '#b88b5b',
            bg: '#f4ead6',
        };
        // #endregion

        // #region --- 2. DOM Element References ---
        const $ = (selector) => document.querySelector(selector);
        const $$ = (selector) => document.querySelectorAll(selector);

        const elements = {
            app: $('#app'),
            header: $('#main-header'),
            blogTitle: $('#blog-title'),
            indexView: $('#index-view'),
            articleView: $('#article-view'),
            tableBody: $('#articles-tbody'),
            tableContainer: $('#table-container'),
            sidebarMenu: $('#sidebar-menu'),
            articleContainer: $('#article-container'),
            articleSpinner: $('#article-spinner'),
            filterInput: $('#filter-input'),
            matchCount: $('#match-count'),
            // Settings
            settingsIcon: $('#settings-icon'),
            settingsPanel: $('#settings-panel'),
            settingsOverlay: $('#settings-overlay'),
            fontSizeSlider: $('#font-size-slider'),
            fontSizeValue: $('#font-size-value'),
            accentColorPicker: $('#accent-color-picker'),
            bgColorPicker: $('#bg-color-picker'),
            resetThemeBtn: $('#reset-theme-btn'),
            contrastWarning: $('#contrast-warning'),
        };
        // #endregion

        // #region --- 3. Theme & Customization ---
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? { r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null;
        }

        function getLuminance(r, g, b) {
            const a = [r, g, b].map(v => {
                v /= 255;
                return v <= 0.03928 ? v / 12.92 : Math.pow((v + 0.055) / 1.055, 2.4);
            });
            return a[0] * 0.2126 + a[1] * 0.7159 + a[2] * 0.0722;
        }

        function getContrast(rgb1, rgb2) {
            const lum1 = getLuminance(rgb1.r, rgb1.g, rgb1.b);
            const lum2 = getLuminance(rgb2.r, rgb2.g, rgb2.b);
            const brightest = Math.max(lum1, lum2);
            const darkest = Math.min(lum1, lum2);
            return (brightest + 0.05) / (darkest + 0.05);
        }

        function rgbToHex(r, g, b) {
            const componentToHex = (c) => {
                const hex = Math.round(c).toString(16);
                return hex.length == 1 ? "0" + hex : hex;
            };
            return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);
        }

        function applyTheme(theme) {
            const root = document.documentElement;
            root.style.setProperty('--scale', theme.scale);
            root.style.setProperty('--accent', theme.accent);
            root.style.setProperty('--bg', theme.bg);

            // Derive text color for contrast
            const bgRgb = hexToRgb(theme.bg);
            if (bgRgb) {
                const isDarkBg = getLuminance(bgRgb.r, bgRgb.g, bgRgb.b) < 0.5;
                const textColor = isDarkBg ? '#f0f0f0' : '#3d352a';
                const headingColor = isDarkBg ? '#ffffff' : '#2c251d';
                const mutedColor = isDarkBg ? '#9e9e9e' : '#857f75';
                root.style.setProperty('--text', textColor);
                root.style.setProperty('--heading-text', headingColor);
                root.style.setProperty('--muted', mutedColor);
                
                // Derive card background color
                let cardBgColor;
                if (isDarkBg) {
                    // For dark themes, make the card slightly lighter than the background
                    cardBgColor = rgbToHex(bgRgb.r * 1.3, bgRgb.g * 1.3, bgRgb.b * 1.3);
                } else {
                    // For light themes, mix the background with white for a soft paper effect
                    cardBgColor = rgbToHex(bgRgb.r * 0.47 + 255 * 0.47, bgRgb.g * 0.47 + 255 * 0.47, bgRgb.b * 0.47 + 255 * 0.47);
                }
                root.style.setProperty('--card-bg', cardBgColor);

                // Check contrast
                const textRgb = hexToRgb(textColor.substring(1));
                const contrast = getContrast(bgRgb, textRgb);
                if(contrast < 4.5) {
                    elements.contrastWarning.textContent = `Poor contrast (${contrast.toFixed(2)})`;
                } else {
                    elements.contrastWarning.innerHTML = '&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;';
                }
            }

            // Update UI controls
            elements.fontSizeSlider.value = theme.scale;
            elements.fontSizeValue.textContent = `${theme.scale}x`;
            elements.accentColorPicker.value = theme.accent;
            elements.bgColorPicker.value = theme.bg;
            elements.accentColorPicker.parentElement.style.backgroundColor = theme.accent;
            elements.bgColorPicker.parentElement.style.backgroundColor = theme.bg;
        }

        function saveTheme(theme) {
            localStorage.setItem('blog-theme', JSON.stringify(theme));
        }

        function loadTheme() {
            const saved = localStorage.getItem('blog-theme');
            return saved ? JSON.parse(saved) : { ...defaultTheme };
        }

        function setupThemeControls() {
            const currentTheme = loadTheme();
            applyTheme(currentTheme);

            elements.fontSizeSlider.addEventListener('input', (e) => {
                currentTheme.scale = parseFloat(e.target.value).toFixed(2);
                applyTheme(currentTheme);
                saveTheme(currentTheme);
            });
            elements.accentColorPicker.addEventListener('input', (e) => {
                currentTheme.accent = e.target.value;
                applyTheme(currentTheme);
                saveTheme(currentTheme);
            });
            elements.bgColorPicker.addEventListener('input', (e) => {
                currentTheme.bg = e.target.value;
                applyTheme(currentTheme);
                saveTheme(currentTheme);
            });
            elements.resetThemeBtn.addEventListener('click', () => {
                Object.assign(currentTheme, defaultTheme);
                applyTheme(defaultTheme);
                saveTheme(defaultTheme);
            });
            elements.settingsIcon.addEventListener('click', () => {
                elements.settingsPanel.style.display = 'block';
                elements.settingsOverlay.style.display = 'block';
            });
            elements.settingsOverlay.addEventListener('click', () => {
                elements.settingsPanel.style.display = 'none';
                elements.settingsOverlay.style.display = 'none';
            });
        }
        // #endregion

        // #region --- 4. Data Fetching & Parsing ---
        async function fetchArticleHTML(slug) {
            try {
                // In a real setup, you might use `/articles/${slug}.html`
                const response = await fetch(`articles/${slug}.html`);
                if (!response.ok) throw new Error(`Article not found: ${slug}`);
                return await response.text();
            } catch (error) {
                console.error('Failed to fetch article:', error);
                return `<article class="post"><h1 class="post-title">Error</h1><p>Could not load article: ${slug}.html</p></article>`;
            }
        }

        function parseArticleFragment(html) {
            const doc = new DOMParser().parseFromString(html, 'text/html');
            return doc.querySelector('article.post');
        }
        
        async function fetchAllArticles() {
            const manifest = [
              {
                "slug": "2025-08-10-c-tokenizer-deep-dive",
                "title": "A Deep Dive into C Tokenization for Syntax Highlighting",
                "date": "2025-08-10",
                "updated": "2025-08-10",
                "authors": "Jane Doe",
                "topics": "#programming #c #parsing #syntax-highlighting"
              },
              {
                "slug": "2025-08-03-handmade-hero-174",
                "title": "Handmade Hero Day 174: Adding Sparse Unicode Support",
                "date": "2025-08-03",
                "updated": "2025-08-10",
                "authors": "Casey Muratori",
                "topics": "#unicode #handmade-hero #tgame-dev"
              },
              {
                "slug": "2025-07-25-spa-architecture-thoughts",
                "title": "Thoughts on Minimalist SPA Architecture",
                "date": "2025-07-25",
                "updated": "2025-07-25",
                "authors": "Jane Doe",
                "topics": "#web-dev #javascript #architecture"
              }
            ];

            // 1. Immediately populate state with manifest data for a fast initial render
            state.articles = manifest.map(meta => ({
                slug: meta.slug,
                date: meta.date,
                last_update: meta.updated,
                title: meta.title,
                authors: meta.authors,
                topics: meta.topics,
                element: null // Initialize element as null
            }));
            
            // 2. Render the table immediately with manifest data
            renderTable();
            updateSortHeaders();

            // 3. Asynchronously fetch and parse each article in the background
            const fetchPromises = state.articles.map(async (article) => {
                try {
                    const html = await fetchArticleHTML(article.slug);
                    article.element = parseArticleFragment(html);
                } catch (error) {
                    console.error(`Failed to fetch article content for ${article.slug}:`, error);
                    // Optionally create an error element to display later
                    const errorElement = document.createElement('article');
                    errorElement.innerHTML = `<h1 class="post-title">Error</h1><p>Could not load article.</p>`;
                    article.element = errorElement;
                }
            });

            // Wait for all fetches to complete (optional, but good for knowing when all data is loaded)
            await Promise.all(fetchPromises);
            console.log("All articles have been fetched and parsed.");
        }
        // #endregion

        // #region --- 5. View & Table Rendering ---
        function highlightMatches(text, regex) {
            if (!regex) return text;
            return text.replace(regex, `<span class="highlight">$&</span>`);
        }

        function renderTable() {
            // 1. Filter
            let filteredArticles = state.articles;
            if (state.filterRegex) {
                filteredArticles = state.articles.filter(article => {
                    const rowString = `${article.date};${article.last_update};${article.title};${article.authors};${article.topics}`;
                    return state.filterRegex.test(rowString);
                });
            }
            elements.matchCount.textContent = `${filteredArticles.length} of ${state.articles.length} shown`;

            // 2. Sort
            const { column, order } = state.sort;
            filteredArticles.sort((a, b) => {
                const valA = a[column];
                const valB = b[column];
                let comparison = 0;
                if (column === 'date' || column === 'last_update') {
                    comparison = new Date(valB) - new Date(valA); // Dates default descending
                } else {
                    comparison = valA.localeCompare(valB);
                }
                return order === 'asc' ? comparison : -comparison;
            });

            // 3. Render
            elements.tableBody.innerHTML = filteredArticles.map((article, index) => `
                <tr data-slug="${article.slug}" tabindex="0" data-index="${index}">
                    <td>${highlightMatches(article.date, state.filterRegex)}</td>
                    <td>${highlightMatches(article.last_update, state.filterRegex)}</td>
                    <td>${highlightMatches(article.title, state.filterRegex)}</td>
                    <td>${highlightMatches(article.authors, state.filterRegex)}</td>
                    <td>${highlightMatches(article.topics, state.filterRegex)}</td>
                </tr>
            `).join('');
            
            // Also render the narrow sidebar menu
            renderSidebarMenu();
        }
        
        function renderSidebarMenu() {
            const tableHTML = `
                <table class="articles-table">
                    <tbody>
                        ${state.articles.map(article => `
                            <tr data-slug="${article.slug}">
                                <td class="date-cell">${article.last_update}</td>
                                <td class="title-cell">${article.title}</td>
                            </tr>`).join('')}
                    </tbody>
                </table>`;
            elements.sidebarMenu.innerHTML = tableHTML;
        }

        function updateSortHeaders() {
            $$('.articles-table th').forEach(th => {
                const column = th.dataset.sort;
                if (column === state.sort.column) {
                    th.setAttribute('aria-sort', state.sort.order === 'asc' ? 'ascending' : 'descending');
                } else {
                    th.removeAttribute('aria-sort');
                }
            });
        }
        // #endregion

        // #region --- 6. Routing & Navigation ---
        function generatePostMeta(articleElement) {
            if (!articleElement) return;

            const metaContainer = articleElement.querySelector('.post-meta');
            if (!metaContainer) return; // If an article has no meta section, do nothing.

            const { date, updated, authors, topics } = articleElement.dataset;
            let metaHTML = '';

            // Date and Updated Date
            if (date) {
                let dateHTML = `<div><time class="post-date">${date}</time>`;
                // Only show 'updated' if it exists and is different from the original date
                if (updated && updated !== date) {
                    dateHTML += `, updated on <time class="post-updated">${updated}</time>`;
                }
                dateHTML += `</div>`;
                metaHTML += dateHTML;
            }

            // Authors
            if (authors) {
                metaHTML += `<div class="post-authors">${authors}</div>`;
            }

            // Topics 
            if (topics) {
                const topicsHTML = topics
                    .split('#')
                    .map(tag => tag.trim())      // First, trim all potential tags
                    .filter(tag => tag)          // Then, remove any that are now empty
                    .map(tag => `<span class="tag">${tag}</span>`)
                    .join(' ');
                
                // Only add the topics container if there are actual topics to display
                if (topicsHTML) {
                    metaHTML += `<div class="post-topics">${topicsHTML}</div>`;
                }
            }

            metaContainer.innerHTML = metaHTML;
        }

        function showIndexView() {
            elements.indexView.style.display = 'block';
            elements.articleView.style.display = 'none';
            if (location.hash) {
                history.pushState("", document.title, window.location.pathname + window.location.search);
            }
            state.focusedRowIndex = -1;
        }

        async function showArticleView(slug) {
            elements.indexView.style.display = 'none';
            elements.articleView.style.display = 'grid';
            elements.articleContainer.innerHTML = '';
            elements.articleSpinner.style.display = 'block';

            // Highlight active item in sidebar
            $$('#sidebar-menu tr').forEach(row => {
               row.style.fontWeight = row.dataset.slug === slug ? 'bold' : 'normal';
            });

            const article = state.articles.find(a => a.slug === slug);

            if (article && article.element) {
                // Content was already pre-fetched
                elements.articleContainer.innerHTML = article.element.outerHTML;
            } else {
                // Content not ready or article not in manifest (deep link), fetch it now
                const html = await fetchArticleHTML(slug);
                const element = parseArticleFragment(html);
                elements.articleContainer.innerHTML = element ? element.outerHTML : 'Article not found.';
                // If the article was in the manifest, store the fetched element
                if (article) {
                    article.element = element;
                }
            }
            
            generatePostMeta(elements.articleContainer.querySelector('.post'));
            highlightAllCodeBlocks();
            
            elements.articleSpinner.style.display = 'none';
            window.scrollTo(0, 0);
            location.hash = `#${slug}`;
        }
        
        function handleRouteChange() {
            const slug = location.hash.substring(1);
            if (slug) {
                showArticleView(slug);
            } else {
                showIndexView();
            }
        }
        // #endregion

        // #region --- 7. C Syntax Highlighter ---
        function escapeHtml(text) {
            return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        }

        function highlightC(code) {
            const tokenRegexes = [
                { type: 'preproc', regex: /^[ \t]*#[^\n]*/m },
                { type: 'comment', regex: /\/\*[\s\S]*?\*\/|\/\/.*/ },
                { type: 'string', regex: /"(?:\\.|[^"\\])*"/ },
                { type: 'char', regex: /'(?:\\.|[^'\\])'/ },
                { type: 'number', regex: /\b(?:0x[0-9a-fA-F]+|0[0-7]*|\d+(?:\.\d+)?(?:[eE][+-]?\d+)?)\b/ },
                { type: 'keyword', regex: /\b[a-zA-Z_][a-zA-Z0-9_]*\b/ }
            ];
            
            let result = '';
            let pos = 0;
            while (pos < code.length) {
                let bestMatch = null;
                for (const { type, regex } of tokenRegexes) {
                    const stickyRegex = new RegExp(regex.source, 'y'); // Use sticky flag to match from current pos
                    stickyRegex.lastIndex = pos;
                    const match = stickyRegex.exec(code);
                    if (match) {
                        if (!bestMatch || match[0].length > bestMatch.match[0].length) {
                            bestMatch = { type, match };
                        }
                    }
                }
                
                if (bestMatch) {
                    const text = bestMatch.match[0];
                    let tokenType = bestMatch.type;
                    if (tokenType === 'keyword' && !C_KEYWORDS.has(text)) {
                        tokenType = 'identifier'; // Don't highlight identifiers
                    }
                    
                    if (tokenType !== 'identifier') {
                        result += `<span class="tk-${tokenType}">${escapeHtml(text)}</span>`;
                    } else {
                        result += escapeHtml(text);
                    }
                    pos += text.length;
                } else {
                    result += escapeHtml(code[pos]);
                    pos++;
                }
            }
            return result;
        }

        function highlightAllCodeBlocks() {
            $$('#article-container code.lang-c').forEach(block => {
                const highlighted = highlightC(block.textContent);
                block.innerHTML = highlighted;
            });
        }
        // #endregion

        // #region --- 8. Event Handlers & Keyboard Shortcuts ---
        function handleFilterInput(e) {
            const value = e.target.value;
            if (!value) {
                state.filterRegex = null;
            } else {
                try {
                    // Support /pattern/flags format
                    const match = value.match(/^\/(.*)\/([gimyusv]*)$/);
                    if (match) {
                        state.filterRegex = new RegExp(match[1], match[2] + (match[2].includes('g') ? '' : 'g'));
                    } else {
                        state.filterRegex = new RegExp(value, 'gi'); // Default to global, case-insensitive
                    }
                    elements.filterInput.style.color = '';
                } catch (err) {
                    state.filterRegex = null;
                    elements.filterInput.style.color = 'red';
                }
            }
            renderTable();
        }

        function handleTableHeaderClick(e) {
            const header = e.target.closest('th');
            if (!header) return;
            const column = header.dataset.sort;
            if (state.sort.column === column) {
                state.sort.order = state.sort.order === 'asc' ? 'desc' : 'asc';
            } else {
                state.sort.column = column;
                state.sort.order = 'asc';
            }
            updateSortHeaders();
            renderTable();
        }
        
        function handleTableRowClick(e) {
            const slug = e.target.closest('tr')?.dataset?.slug;
            if (slug) {
                showArticleView(slug);
            }
        }
        
        function focusRow(index) {
            const rows = $$('#articles-tbody tr');
            if (index < 0 || index >= rows.length) return;
            
            state.focusedRowIndex = index;
            rows.forEach((row, i) => {
                if (i === index) row.focus();
                else row.blur();
            });
        }
        
        function handleKeyboardShortcuts(e) {
            const isEditingText = e.target.matches('input, textarea');
            
            if (e.key === '/' && !isEditingText) {
                e.preventDefault();
                elements.filterInput.focus();
                elements.filterInput.select();
            } else if (location.hash && e.key === 'Escape') {
                e.preventDefault();
                showIndexView();
            }
            
            // Table navigation (only in index view)
            if (!location.hash) {
                const rows = $$('#articles-tbody tr');
                if (rows.length === 0) return;
                
                if (e.key === 'j' && !isEditingText) {
                    e.preventDefault();
                    focusRow(Math.min(state.focusedRowIndex + 1, rows.length - 1));
                } else if (e.key === 'k' && !isEditingText) {
                    e.preventDefault();
                    focusRow(Math.max(state.focusedRowIndex - 1, 0));
                } else if (e.key === 'Enter' && document.activeElement.tagName === 'TR') {
                    e.preventDefault();
                    showArticleView(document.activeElement.dataset.slug);
                } else if (e.key === 'PageDown') {
                    e.preventDefault();
                    elements.tableContainer.scrollTop += elements.tableContainer.clientHeight;
                } else if (e.key === 'PageUp') {
                    e.preventDefault();
                    elements.tableContainer.scrollTop -= elements.tableContainer.clientHeight;
                }
            }
        }
        // #endregion

        // #region --- 9. Initialization ---
        async function init() {
            setupThemeControls();

            // fetchAllArticles now handles the initial render and then fetches content.
            // No need to await it here, as we want the UI to be interactive immediately.
            fetchAllArticles();

            // Event Listeners
            elements.filterInput.addEventListener('input', handleFilterInput);
            $$('.articles-table thead').forEach(head => head.addEventListener('click', handleTableHeaderClick));
            elements.tableBody.addEventListener('click', handleTableRowClick);
            elements.sidebarMenu.addEventListener('click', handleTableRowClick);
            elements.blogTitle.addEventListener('click', (e) => { e.preventDefault(); showIndexView(); });

            document.addEventListener('keydown', handleKeyboardShortcuts);
            window.addEventListener('hashchange', handleRouteChange);
            
            // Initial route handling
            handleRouteChange();
        }

        init();
        // #endregion
    });
    </script>
</body>
</html>
